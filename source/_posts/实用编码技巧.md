---
title: 实用编码技巧
date: 2019-04-19 15:28:16
tags: [code]
cover_img:
feature_img:
description:
keywords:
---
### 开放-封闭原则
经常会遇到一种场景，自己维护一个接手的老项目。一个简单事例：在window.onload函数中打印出所有节点的数量。
```
// 最简单的做法
window.onload = function() {
    // 原有代码略
    console.log(document.getElementsByTagName('*').length)
}
```
```
// 遵从开发-封闭原则，不修改原有代码完成新需求
Function.prototype.after=function(afterfn){
    var __self=this;
    return function(){
        var ret=__self.apply(this,arguments);
        afterfn.apply(this,arguments);
        return ret;
    }
};
window.onload=(window.onload||function(){}).after(function(){
    console.log(document.getElementsByTagName('*').length);
});
```

### 对象的多态性消除条件分支
```
var makeSound=function(animal){
    if(animal instanceof Duck){
        console.log('嘎嘎嘎');
    }else if(animal instanceof Chicken){
        console.log('咯咯咯');
    }
};

var Duck=function(){};
var Chicken=function(){};
makeSound(new Duck());//输出：嘎嘎嘎
makeSound(new Chicken());//输出：咯咯咯
```
当需要增加一个狗的时候，我们常规的做法就是进行增加条件判断。
```
var makeSound=function(animal){
    if(animal instanceof Duck){
        console.log('嘎嘎嘎');
    }else if(animal instanceof Chicken){
        console.log('咯咯咯');
    } else if (animal instanceof Dog) {
        console.log('汪汪汪');
    }
};

var Duck=function(){};
var Chicken=function(){};
var Dog = function() {};
makeSound(new Duck());//输出：嘎嘎嘎
makeSound(new Chicken());//输出：咯咯咯
makeSound(new Dog()); //输出：汪汪汪
```
上面的方式也可以实现功能。但是当需求增多的时候，需要修改的部分比较多。利用多态的思想，我们把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。当我们想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的makeSound函数：
```
var makeSound=function(animal){
    animal.sound();
};
var Duck=function(){};
Duck.prototype.sound=function(){
    console.log('嘎嘎嘎');
};
var Chicken=function(){};
Chicken.prototype.sound=function(){
    console.log('咯咯咯');
};
makeSound(new Duck());//嘎嘎嘎
makeSound(new Chicken());//咯咯咯
/*********增加动物狗，不用改动原有的makeSound函数****************/
var Dog=function(){};
Dog.prototype.sound=function(){
    console.log('汪汪汪');
};
makeSound(new Dog());//汪汪汪
```