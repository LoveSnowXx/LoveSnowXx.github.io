[{"title":"蜜芽内容小程序","url":"/2019/04/19/“蜜芽内容小程序”/","content":"### 工时预估\n#### 重构估时\n1. 登录模块 重构0.6\n2. 品牌模块 重构1\n3. 首页模块 重构1\n4. 我的模块 重构0.5\n\n#### 各模块估时\n- 重构总时间 3.1\n- 基本交互总时间 3\n- 数据交互总时间 3\n- 开发总耗时 1\n\n#### \b联调测试\b估时\n联调测试总时间 8.1\n\n#### 项目开发上线总耗时\n预计总花费工时为 20.1\n### 问题整理\n1. 首页搜索是跳转新页面\n2. 点赞样式不可点赞会不会对用户差生困惑\n3. 首页banner：取后台配置banner，点击跳转到配置链接。（这个是所有人都跳到后台配置页面吗？）\n4. 用户昵称过长的截断…（字数多长进行截断）\n\n### 工程化技术栈选择\n\n### 结构拆分\n1. 登录模块\n  - 弹窗\n  - 倒计时\n  - 电话号码脱敏\n2. 品牌模块\n  - tab切换\n  - 富文本解析\n  - 视频播放\n3. 首页模块\n  - swiper\n  - 搜索\n  - 图片预览\n  - 左右两侧瀑布流\n  - 富文本解析\n4. 我的\n### 组件拆分\n我的-我喜欢的item === 首页-今日精选item\n\n品牌\n- 品牌新闻item\n- 品牌故事item\n- 品牌素材item微信小程序+前端架构微信小程序+前端架构\n\n首页\n- 热门分类item\n- 评论item\n### 复用代码块\n1. 显示省略号\n```\n// 单行省略号\nwhite-space: nowrap;\noverflow: hidden;\ntext-overflow: ellipsis;\n\n// 多行省略号\ndisplay: -webkit-box;\noverflow: hidden;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n\n// 多行省略号\n.wrap {\n  height: 40px;\n  line-height: 20px;\n  overflow: hidden;\n}\n.wrap .text {\n  float: right;\n  margin-left: -5px;\n  width: 100%;\n  word-break: break-all;\n}\n.wrap::before {\n  float: left;\n  width: 5px;\n  content: '';\n  height: 40px;\n}\n.wrap::after {\n  float: right;\n  content: \"...\";\n  height: 20px;\n  line-height: 20px;\n  /* 为三个省略号的宽度 */\n  width: 3em;\n  /* 使盒子不占位置 */\n  margin-left: -3em;\n  /* 移动省略号位置 */\n  position: relative;\n  left: 100%;\n  top: -20px;\n  padding-right: 5px;\n}\n```\n2. 流式布局\n```\n```\n3. 修改页面title\n```\nwx.setNavigationBarTitle({\n  title: '当前页面'\n})\n```\n4. 懒加载\n5. 图片限宽高度自适应\n```\nmode=\"widthFix\"\n```\n6. 时间格式化\n7. 倒计时\n\n"},{"title":"关于小前端团队的思考","url":"/2019/04/19/“关于小前端团队的思考”/","content":"### 如何提高团队成员的技术竞争力\n1. 深入框架实现原理\n2. 设计模式\n3. 算法\n\n### 解决业务关键人物问题\n1. CodeReview\n2. "},{"title":"实用编码技巧","url":"/2019/04/19/实用编码技巧/","content":"### 开放-封闭原则\n经常会遇到一种场景，\b自己维护一个接手的老项目。一个简单事例：在window.onload函数中打印出所有节点的数量。\n```\n// 最简单的做法\nwindow.onload = function() {\n    // 原有代码略\n    console.log(document.getElementsByTagName('*').length)\n}\n```\n```\n// 遵从开发-封闭原则，不修改原有代码完成新需求\nFunction.prototype.after=function(afterfn){\n    var __self=this;\n    return function(){\n        var ret=__self.apply(this,arguments);\n        afterfn.apply(this,arguments);\n        return ret;\n    }\n};\nwindow.onload=(window.onload||function(){}).after(function(){\n    console.log(document.getElementsByTagName('*').length);\n});\n```\n\n### 对象的多态性消除条件分支\n```\nvar makeSound=function(animal){\n    if(animal instanceof Duck){\n        console.log('嘎嘎嘎');\n    }else if(animal instanceof Chicken){\n        console.log('咯咯咯');\n    }\n};\n\nvar Duck=function(){};\nvar Chicken=function(){};\nmakeSound(new Duck());//输出：嘎嘎嘎\nmakeSound(new Chicken());//输出：咯咯咯\n```\n当需要增加一个狗的时候，我们常规的做法就是进行增加条件判断。\n```\nvar makeSound=function(animal){\n    if(animal instanceof Duck){\n        console.log('嘎嘎嘎');\n    }else if(animal instanceof Chicken){\n        console.log('咯咯咯');\n    } else if (animal instanceof Dog) {\n        console.log('\b汪汪汪');\n    }\n};\n\nvar Duck=function(){};\nvar Chicken=function(){};\nvar Dog = function() {};\nmakeSound(new Duck());//输出：嘎嘎嘎\nmakeSound(new Chicken());//输出：咯咯咯\nmakeSound(new Dog()); //输出：汪汪汪\n```\n上面的方式也可以实现功能。但是当需求增多的时候，需要修改的部分比较多。利用多态的思想，我们把程序中不变的部分隔离出来（动物都会叫），然后把可变的部分封装起来（不同类型的动物发出不同的叫声），这样一来程序就具有了可扩展性。当我们想让一只狗发出叫声时，只需增加一段代码即可，而不用去改动原有的makeSound函数：\n```\nvar makeSound=function(animal){\n    animal.sound();\n};\nvar Duck=function(){};\nDuck.prototype.sound=function(){\n    console.log('嘎嘎嘎');\n};\nvar Chicken=function(){};\nChicken.prototype.sound=function(){\n    console.log('咯咯咯');\n};\nmakeSound(new Duck());//嘎嘎嘎\nmakeSound(new Chicken());//咯咯咯\n/*********增加动物狗，不用改动原有的makeSound函数****************/\nvar Dog=function(){};\nDog.prototype.sound=function(){\n    console.log('汪汪汪');\n};\nmakeSound(new Dog());//汪汪汪\n```"},{"title":"西安落户","url":"/2019/04/14/西安落户/","content":"最近\b计划买房，看到一些人都有这个疑问，同样的我操作的时候也有一些疑惑。接下来把步骤写一下。\n\n1. 微信搜索\b“西安公安”\n2. 下方菜单\b“掌上户籍室”\n3. 点击\b“学历落户”\n   ![](/images/1.jpg)\n4. “在线申报”\n5. 选择办事单位、申请入户地址（需要和置业顾问沟通）\n6. 填完必填项。寄送方式：建议去派出所。不到5min就处理完。\n\n```建议打印毕业证、身份证。办理完就只有一张户籍卡，至此就是一名西安市公民了。```\n","tags":["西安落户"]},{"title":"中介者模式","url":"/2019/04/14/中介者模式/","content":"中介者模式的作用就是解除对象和对象之间的紧耦合关系。中介者使各对象之间耦合松散，而且可以独立地改变他们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。\n\n现实中的例子：\n\n1. 机场指挥塔\n\n      每架飞机不需和所有飞机通信，只需和指挥塔通信。指挥塔知道每架飞机的飞行状况，所以它可以安排所有飞机的起降时间，及时作出航线调整。\n2. 博彩公司\n\n      不可能上千万人一起计算赔率和输赢。有了博彩公司作为中介，每个人只需和博彩公司发生关联，博彩公司会根据所有人的投注情况计算好赔率，彩民们赢了钱就从博彩公司拿，输了钱就交给博彩公司。\n\n\n\n","tags":["设计模式"]},{"title":"职责链模式","url":"/2019/04/14/职责链模式/","content":"职责链模式的定义：使多个对象都有机会处理请求，从而避免请求的发送者和\b接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n现实中的自责链模式：\n\n1. 挤公交车时传递公交卡\n2. 考试作弊时传答案\n\n","tags":["设计模式"]},{"title":"享元模式","url":"/2019/04/14/享元模式/","content":"享元模式是为解决性能问题而生的模式。在一个存在大量相似对象的系统中，享元模式可以很好的解决大量对象带来的性能问题。\n\n以下情况发生时可以使用享元模式。\n\n- 一个程序使用了大量的相似对象\n- 由于使用了大量对象，造成很大的内存开销\n- 对象的大多数状态都可以变为外部状态\n- \b剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。","tags":["设计模式"]},{"title":"相信时间的力量","url":"/2019/04/13/相信时间的力量/","content":"### 接受不安\n有时候，我发现自己会没来由的不开心或者情绪失落。又或者是早上心情很好，自信满满，情绪高涨，全是积极向上的情绪。但到了中午或者下午又或者是晚上，就会没来由的失落。我们要接受这是一种正常的，合理的表现。\n\n在负面情绪很激烈的时候，需要暗示自己。“交给时间，一切都会过去的”。所以也就需要做到平常心，志得意满时留一分，灰心丧气时打打气。\n\n这样也\b更容易做到不和别人攀比，更多的专注于自己内心的想法和感受。\n\n### 时间有魔力\n从去年到现在，个人感觉经历还算丰富。先是从上市公司辞职，然后自己创业。创业失败之后，进入一家E轮融资的母婴电商任职。\n\n这中间还包括爱情。去年1月23号，我刚认识现在的女友。根本不敢想象，在追了276天终于追到了女神。同时也结束了第一份工作。开启了第一份创业。很多人都想要创业，但都没走出这一步。我走出了这一步，只是结果不尽如人意。\n\n以上想表达的就是，时间总会给人惊喜。在当下某一个阶段觉得比较难的时候，坚持住。困境总会过去的。同样的，当下不管有多么得意，也需要保持敬畏之心。人生起起伏伏，保持正常心。\n\n\n","tags":["情绪","时间","随笔"]},{"title":"西安住房公积金问题","url":"/2019/04/10/西安住房公积金问题/","content":"### 外地有社保和公积金，西安住房公积金显示未查询到账户\n- 西安是否可以补交社保、公积金\n  社保可以补缴。公积金未详细咨询\n- 是否可以将外地转移至西安，有断缴是否可以补交\n  社保公积金可以转移。需要在西安开户一个月以后，将外地的转回来\n- 补交的购房是否可以按照满两年社保（无需迁移户口），或者使用公积金贷款\n  有部分社保补缴公司承诺可以内部操作，无补缴标记。\n- 如果转回来补交了，那在西安交社保的时间是从一开始在外地交的就算，还是按照补缴西安的这段时间算\n  该问题没有持续跟进\n\n### 如果不可以使用公积金贷款，商业贷款购房，满两年社保之后是否可以切换为公积金贷款\n  西安市公积金管理中心回复不可以。[商业贷款转公积金](0http://zfgjj.xa.gov.cn/hdjl/zxhf_xx.jsp?urltype=guestbook.GbBookDetailUrl&wbtreeid=1353&wbguestbookid=88219)\n","tags":["西安买房","住房公积金"]},{"title":"V16.3 React","url":"/2019/04/01/V16-3-React/","content":"### React V16.3\n\n#### 新增生命周期函数：\n\n- getDerivedStateFromProps\n- getSnapshotBeforeUpdate\n\ngetDerivedStateFromProps替代componentWillReceiveProps。\n\nAjax请求放在componentDidMount更合适。因为componentWillMount可能会被调用多次。\n\n#### deprecate周期函数\n\n- componentWillReceiveProps\n- componentWillMount\n- componentWillUpdate\n\ngetDerivedStateFromProps取代componentWillReceiveProps是不准确的说法。因为componentWillReceiveProps只在Updating过程中才被调用，而且只在因为父组件引发的Updating过程中才被调用。**getDerivedStateFromProps在Updating和Mounting过程中都会被调用。**\n\n#### 总结\n\n用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，而已。","tags":["前端","React"]},{"title":"Hello World","url":"/2019/03/31/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n### hexo s正常，hexo d不能推远程\n```\n1. hexo clean\n2. hexo g\n3. hexo s\n4. hexo d\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]